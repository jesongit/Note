# 一级标题

## 初识

### 编译

- 编译器：把源代码转换成可执行代码的程序
- 一般的编译过程有两步
  - 编译：编译器将源代码转换成目标代码
  - 链接：链接器将目标代码和其他代码（库代码、启动代码）合并为可执行代码
  - 目标代码只有源代码的机器语言代码，可执行代码包含了源代码、库代码以及启动代码的机器语言代码

### 示例

```c
// 这是一行注释
#include <stdio.h>    // 包含另一个文件，预处理指令

int main(void)        // 入口函数，总是第一个被调用
{                     // 一个函数的开始
  /*
      这是一个多行注释
     */
    
    // 下面的都是语句，语句都是以分号结尾
    int num;              // 声明
    num = 1;              // 赋值 把 1 复制给 num 这个变量
    printf("%d\n", num);  // 调用一个函数
    return 0;             // 返回值，函数的返回
}                         // 一个函数的结束
```

### 关键字和保留标识符

|           |          |              |                    |
| --------- | -------- | ------------ | ------------------ |
| auto      | extern   | short        | while              |
| break     | float    | **signed**   | ***_Alignas***     |
| case      | for      | sizeof       | ***_Alignof***     |
| char      | goto     | static       | ***Atomic***       |
| **const** | if       | struct       | **_Bool**          |
| continue  | inline   | switch       | **_Complex**       |
| default   | int      | typedef      | **_Generic**       |
| do        | long     | union        | **_Imaginary**     |
| double    | register | unsigned     | **_Noreturn**      |
| else      | restrict | void         | **_Static_assert** |
| **enum**  | return   | **volatile** | **_Thread_local**  |

### 变量与常量

- 常量：数据类型在使用前预先设定好了，切在运行过程中没有变化
- 变量：数据类型可能会改变，且可能被复赋值
- 字面量: 无法被修改，只能作为右值使用，如 123, "str"

### 预处理器指令

```c
#include <math.h> // 包含数学相关的一些函数，下面就可以直接使用
#define MAX 100   // 后面的所有 MAX 会被替换为 100 字母全大写命名是确定
```

## 数据类型

### 关键字

| 最初的关键字 | C90添加关键字 | C99添加关键字 |
| ----------- | ------------ | ------------ |
| int         | signed       | _Bool        |
| long        | void         | _Complex     |
| short       |              | _Imaginary   |
| unsigned    |              |              |
| char        |              |              |
| float       |              |              |
| double      |              |              |

### 位、字节和字

- 位（bit）：最小的存储单位，可以存储 0 或 1，位是计算机内存的基本构建块
- 字节（byte）：常用的计算机存储单位，1 字节 = 8 位
- 字（word）：是计算机给定的自然存储单位。现在基本上都是 64 位的计算机

### 整数和浮点数

- 整数没有小数，浮点数有小数，他们的区别是**存储方式**不一样
- 整数直接存储，而浮点数需要将整数部分和小数部分**分开存储**
- 小数部分有长度限制，运算后存在**精度损失**，浮点运算会更慢

### 基础数据类型

#### `int` 类型

- `int` 必须是整数，可以是正整数、负整数或者 0
- `int` 的取值范围因系统而异，一般为 16-64 位不等
- `int` 存在正负，最高位为符号位，0 表示正数，1 表示负数

 一个整数(1、2...) 是一个整型字面量/整型常量
 C 语言中会将大多数整数视为 int 类型，除非他非常大

```c
// 通常使用以下方式使用 int 类型
// 声明便会分配内存空间，初始化/赋值便是将值填入对应的空间
int a;      // 声明一个 int 变量
int a = 5;  // 声明并初始化一个 int 变量
int a, b;   // 当然也可以多个
int a = 5, b = 6;
int a = 06; // 八进制表示
int a = 0x6;// 十六进制(0X6也可以)


// 打印 int
// %o %x 是无符号的，如果打印一个负数，会打印错误
int a = 16;
printf("%d\n", a);  // 16
printf("%o\n", a);  // 20   (8 进制)
printf("%x\n", a);  // 10   (16进制)
printf("%#o\n", a); // 020
printf("%#x\n", a); // 0x10
printf("%#X\n", a); // 0X10
```

#### 其他整型

C 语言提供 3 个关键词修饰基本整型类型 `short` `long` `unsigned`

- `short int`: 简写 `short`，**可能**占用更小空间用于数值较小的情况，用于节省空间 
- `long int` : 简写 `long`，`long` **可能**占用比 `int` 更大的空间
- `long long int`: 简写 `long long`，占用空间比 `long` 更多
- 以上类型都是有符号的，也可以显式添加 `signed` 关键字，他们是等效的
- 如果添加 `unsigned` 关键字，表示无符号整数，符号位也记录值，可以表示更大的整数

> C 语言中只规定了 `short` 不大于 `int`，`long` 不小于 `int`
这样规定是为了适应不同的机器，在不同的机器上，`int`位数也不同

```c
// 使用 l/L 结尾可以显示使用 long 整型常量
long a = 1;
long b = 1 + 2L;    // 这里的 2L 是一个 long 类型的整型常量
// unsigned -> u/U    long long -> ll/LL
unsigned long long a = 1;
unsigned long long b = 1 + 2ull;

// 打印, 转换说明中只能用小写字母
// 转换说明和参数不匹配，可能带来意想不到的结果
printf("%u\n", a);  // 打印 unsigned int
printf("%h\n", a)   // 打印 short
printf("%ld\n, a);  // 打印 long
printf("%lo\n, a);  // 打印 long (8 进制)
printf("%llu\n", a);// 打印 unsigned long long
```

#### `char` 类型

 > 占 8 位的空间，表示计算机中的基本字符集，当然实际上也是一个整数

 ```c
 // 初始化/赋值
 char c = 'a';  // 初始化一个值为字母 'a' 的字符变量
 char c = 97;   // 同上是等效的，因为 'a' 的 ASCII 码就是 97, 推荐使用上面的方式

 // 因为 char 只占 8 位， 如果赋值一个 32位 的值
 char c = 'abcd';   // 只有最后 8 位有效
 printf("%c\n", c); // d
 ```

 通常的数字、字母和符号都可以使用单引号的形式表示，还有一些特殊的转移序列
 | 转移序列 | 含义      | 转移序列 | 含义 |
 | ------- | ----       | ---     | --- |
 | \a      | 警报       | \b      | 退格 |
 | \f      | 换页       | \n      | 换行 |
 | \r      | 回车       | \t      | 水平制表符 |
 | \v      | 垂直制表符 | \\\\    | 反斜杠 |
 | \\'     | 单引号    | \\"     | 双引号 |
 | \\?     | 问号      | \0oo    | 八进制值(\010, \10也可以) |
 | \xhh    | 十六进制值(\xff) |

 一些整型常量的例子
 | 类型 | 16 进制 | 8 进制 | 10 进制 |
 | --- | --- | --- | --- |
 | char | \x41 | \101 | 65 |
 | int | 0x41 | 0101 | 65 |
 | unsigned int | 0x41u | 0101u | 65u |
 | long | 0x41L | 0101L | 65L |
 | unsigned long | 0x41UL | 0101UL | 65UL |
 | long long | 0x41LL | 0101LL | 65LL |
 | unsigned long long | 0x41ULL | 0101ULL | 65ULL |

##### 遇到的问题

 ```c
 // 书中写的表格是 char \0x41 \0101 N.A.
 // 但是与上面讲述的 \xhh \0oo 矛盾，猜测是写错了，不排除是我的理解有误，同时测试了一下差别

char c1 = '\x41';
printf("%c %#x %#o %d \n", c1, c1, c1, c1); // A 0x41 0101 64
// 此处等效 c1 = 'A' = 64 = 0101 = 0x41 = '\0x41', \x41 只是以转义序列的方式表示

char c2 = '\0x41';
printf("%c %#x %#o %d \n", c2, c2, c2, c2); // 1 0x31 061  49
// 此处等效 c2 = '1' = 49 = 061 = 0x31
// 这里为什么变成了 '1' 呢，因为 '\0x41' 不是一个转义序列
// 结合上一个代码块中 'abcd' 的示例，可知这里相当于是 c2 = '1'

// 在字符串中可以不需要单引号
printf("\x41\n");   // A
printf("\0x41\n);
// 你可能会好奇为什么第二句没有东西
// 上述例子中，'\0x41' 赋值时候，只有 '1'被赋值到 c2
printf("%c", c2); => printf("1");
// 而此处是一个字符串，\0表示一个字符串结尾
printf("\041"); => printf("");
 ```

##### 有符号与无符号

- 有没有符号会影响 `char` 的取值范围，这取决于编译器怎么做
- 可以指定 `signed` 或 `unsigned` 表示有无符号整数
- 如果你只是用于处理字符，那么有无符号这件事没有什么意义，`char` 即可

#### `_Bool` 类型(C99)

C 语言中使用 1 表示 `true`，0 表示 `false`，不过 `Bool` 只占用一位存储空间

#### 可移植的类型(C99)

> 位于头文件 `stdin.h` `inttypes.h`，保证在不同的环境可以保证功能相同

```c
// 一些例子
int32_t      a = 5; // 精确宽度类型      = 32位
// 有些环境可能无法指定精确宽度类型，还提供了以下类型
int_least8_t a = 5; // 最小宽度类型     >= 8 位
int_fast8_t  a = 5; // 最快最小宽度类型 >= 8 位 （相对运行最快
intmax_t     a = 5; // 有符号最大整数类型
unitmax_t    a = 5; // 无符号最大整数类型
// 此处的最大整数可能比 `long long ` 更大

// 因为同样是 32 位，可能是用 %d 或者 %ld 打印
// inttypes.h 中的宏 PRId32 解决了这个问题
printf("%" PRId32, a); => printf("%d", a); / printf("%ld", a);
```

#### 浮点类型

`float` 其中 8 位表示指数的值和符号，剩下的 24 位表示非指数部分及其符号
`double` 其中 8 位表示指数的值和符号，剩下的 56 位表示非指数部分及其符号
`long double` 满足比 `double` 更高精度的要求，不过 C 只保证与 `double` 精度相同

> 10^-37^ 是 10 的 -37 次方，需要扩展语法支持，可能不是上标的样子，下同

##### 科学计数法、指数计数法和 P 计数法(C99)

| 数字 | 科学计数法 | 指数计数法 | P 计数法 |
| --- | --- | --- | --- |
| 10364.0 | 1.0364 x 10^4^ | 1.0364e4 | 0xa.1fp10 |

```c
// P 计数法说明 以十六进制表示
0xa.1fp10 => a = 10, .1 = 1/16, .0f = 15/256, p10 = 2^10^ = 1024
          => (10 + 1/16 + 15/256) * 1024 = 10364

// 打印 传递参数时，会自动将 float 转换为 double
// 这种情况下，double会更快
printf("%f", f);  // 打印十进制的 float，double
printf("%e", f);  // 打印指数计数法的浮点数(e 或者 E)
pritnf("%a", f);  // 打印十六进制的浮点数(a 或者 A，不一定可以用)
printf("Lf", f);  // long double(Lf, Le, La)
```

##### 浮点数的一些特性

```c
// 上溢
float f = 3.4e38 * 100.0f;  // 3.4e38 接近 float 的上限, 此时发生上溢
printf("%f\n", f);          // inf 也有可能时其他类似字样

// 下溢 以十进制举例子来理解下溢 假设：指数位最多只能是10，尾数位最多只能3位
0.120e10 / 10 = 0.012e10  // 这里除 10 后，指数无法增加，只能后移小数点，当然没什么问题
0.012e10 / 10 = 0.01e10   // 再除 10 后发现，因为存储位数问题，最后一位被截断了，发生下溢
// 精度变小，继续除下去，会让所有尾数都变成 0 

// NaN(not a number)，比如正弦值不能大于 1
printf("%d\n", asin(2));  // nan

// 因为浮点数存在精度问题, 就像永远无法准确表达 1/3 这个小数
2.0e20 + 1.0 - 2.0e20 // 并不会得到 1.0 可能会得到一些很奇怪的答案
```

#### 复数和虚数

> 因为个人几乎不会使用，这里跳过

#### `scanf` 和 `printf`

| 转换说明 | 输出 | 
| --- | --- |
| %a/%A | 浮点数、十六进制和 p 记数法 |
| %c | 单个字符 |
| %d/%i | 有符号十进制整数 |
| %e/%E | 浮点数，e 记数法 |  
| %f | 浮点数，十进制记数法 |


#### 其他问题

```c
// 打印对象占用大小, %zd 不支持可用 %u/%lu 代替
printf("%zd\n", sizeof(int));   // 4
// 对于一个类型 sizeof(int)， 括号是必须的
// 对于一个值 sizeof 1.0，括号是可选的，建议加上括号

// 使用 const 定义一个常量
const int a = 5;  // 初始化或第一次复制后，无法再次被赋值

// limits.h 中定义了所有整数的最大最小值（会根据系统变化）
// float.h 中定义了浮点数的有效位数
```

## 字符串

是一个或多个字符的序列，可以用双引号告诉编译器这是一个字符串

C 语言中没有专门处理字符串的数据类型，使用字符数组来处理

使用空字符 `'\0'` 表示字符串的结束，这点很重要，所以字符数组至少要比字符串长度多一位

### 常用函数

| 函数 | 作用 |
| --- | --- |
| strlen(char *) | 计算字符串长度 |
| strcat(char *, char *) | 连接字符串 |
| strncat(char *, char *, int len) | 仅连接指定长度 |
| strcmp(char *, char *) | 比较字符串 |
| strncmp(char * char *) | 比较指定长度字符串，即开头 |
| strcpy(char *, char *) | 拷贝字符串，返回第一个参数地址 |
| strncpy(char *, char *) | 拷贝指定长度 |
| strchr(char *, char c) | 查找首次出现的位置 |
| strrchar(char *, char c) | 查找最后出的位置 |
| strpbrk(char *, char *) | 查找 s1 中首次出现 s2 中任意字符的位置 |
| strstr(char *, char *) | 查找指定字符串 |
| fprintf(char *, args) | 将输出存储到指定字符串 |




```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <float.h>
#include <string.h>

int main(void)
{
    // int 的最大最小值 limits.h
    // printf("%d %d \n", INT_MIN, INT_MAX);
    // 浮点数有效位数 float.h
    // printf("%d %d \n", FLT_DIG, DBL_DIG);

    // printf 中字符串可用空格分开
    // printf("Hello, young lovers"
    // ", wherever you are.\n");

    // scanf 返回值是转换的个数

    // init array
    // int a[10];               // 无法确定初始值是多少
    // int a[10] = {1};         // 编译器会把第一个值初始成1，其他位置初始为0
    // int a[10] = {[5] = 1}    // 编译器会把第五个值初始化为5，其他为0（C99）
    // int a[10] = {1, [1] = 6} // 第一个值会是6，其他是0
    // int a[] = {1, [3] = 4}   // 数组长度会是 4

    // const

    // 使用 const 保护数组
    // int display(const int arr[]); // 可以保护数组数据不被篡改

    // const int a[] = {0};
    // int * p = a;         // 这是无效的，因为a是const，无法被修改

    // int a[10] = {0};
    // const int* p = a;    // 指针指向的值无法被修改 但是可以通过 a 来修改本来的数组，因为他不是const, 同时也无法保证他无法被指向其他字符串
    // int* const p = a;    // 指针存储的地址无法被修改, 可以改指向的值
    // const int* const p = a;  // 地址和值都不能修改

    // int i, a[5] = {0};
    // const int* p1 = a;
    // a[0] = 1;
    // ++p1;
    // int* const p2 = &a[1];
    // *p2 = 2;
    // for(i = 0; i < 5; ++i) 
    // {
    //     printf("%d\n", a[i]);
    // }

    // int display(const int a[]);
    // int modify(int a[]);
    // display 可以接受 普通数组和 const 数组
    // modify 可以接受普通数组，接受const数组这种行为是未定义的，不要使用


    // 指针注意事项，不要使用初始化的指针，会带来无法预料的问题

    // 字符串
    // 字符串字面量
    // 会在静态存储区中创建对应的字符串字面量，类似 char* str; 无法修改指向的地址
    // const char* str = "hello world";     // 只有在静态存储区中有该字符串，str 指针指向该地址
    // const char str[] = "hello world";    // 会给数组分配一块内存，复制静态存储区的字符串  
    // 即初始化指针只是把地址拷贝过来，初始化数组是将字符串拷贝过来

    // 带来的问题
    // char* str = "hello";
    // str[0] = 'a';
    // printf("hello");        // 此时打印的是 "aello"
    // 字面量 "hello" 的地址为*p，这里将 p 赋值给 str，修改了改地址的值
    // 但是字面量 "hello" 对应的地址不会变，所以打印的是改变后的值
    // 所以，只有当你需要修改字符串时，才用字符指针指向字符串字面量
    // 以上是 C Primer Plus 中描述的情况

    // char* s1 = "hello";
    // s1[0] = 'a';
    // char* s2 = "hello";
    // char s3[] = "hello";
    // printf("%s %s %s", s1, s2, "hello");
    // printf("%p %p %p %p \n", s1, s2, s3, &("hello"));
    // 经测试
    //   clang/gcc 中 不允许 s[0] = 'a' 这种赋值方式，且地址 s1 == s2 == &("hello") != s3，符合书中讲的
    //   tinycc(一款大佬自己撸的轻量级编译器)中，可以使用 s[0] = 'a'; 因为所有地址都不一样，猜测可能所有字符串都是内存中直接创建的
    // 正如书中所描述的，这种行为是未定义的，无法预料的情况应该避免使用

    // 推荐用法
    // 当使用不需要修改的字符串时候，使用 const char* str; 他是只读的
    // 当需要修改字符串时候，使用 char str[]; 他是可以被修改的并且不会造成其他影响

    // 由于以上特性，字符串数组也有两种使用方式
    // char* p[5]; char p[5][10];
    // 前者是5个字符指针的数组，占用内存 sizeof(char*) * 5 = 40 B
    // 后者是5个字符数组的数组，占用内存 sizeof(char) * 10 * 5 = 50 B
    // 字符指针数组一般情况下占用内存更少(当字符长度>4时候)，同时效率更高，但是字符串无法被修改（如上所述，修改的行为是未定义的)
    // 同理，不需要修改时候用指针数组，需要修改用字符二维数组

    // 字符串输入/输出
    // gets(char*): 读取一行的字符串，直到遇到换行，丢弃换行，增加一个\0组成字符串，但是因为无法预料缓存区有多少字符，可能存在溢出问题，不建议使用，C11标准中已被废除
    // puts(char*): 打印一个字符串，会自动添加换行，遇到\0才会停止(所以不要试图打印一个没有结束符的字符串，fputs也是)
    // fgets(char*, int len, file): 从file中读一串字符，遇到换行或者将最大 len - 1 长度的字符串放入数组，ile = stdin 则将标准输入作为参数, 读到文件末尾返回 NULL
    // fputs(char*, file)：打印字符串，不会添加换行，一般配合fgets使用，file = stdout 则为标准输出，如果成功返回字符指针，否则返回空指针NULL
    // gets_s(char* int len): C11 标准新增，较少编译器支持，会丢弃换行符，如果超过 len，会将数组首位设为 \0，并读完缓冲区，调用处理函数（或自定义函数）


    // scanf: 会从非空白字符串读到指定宽度或者第一个空白符（空白符包括空格/空行/制表符/换行符）
    // 返回值：读取成功个数或者EOF(-1)
    // 字符串过长时，也存在溢出问题，可以通过指定宽度来解决
    // ptintf 会比puts慢，因为要处理更多的东西（当然你察觉不到）
    // printf 只会进行转换处理，我们需要保证参数和转换类型正确

    // 常用字符串函数
    // strlen(char*): 统计字符串长度 不包括结束符
    // strcat(char*, char*): 连接字符串
    // strncat(char*, char*, int len): 仅连接指定长度
    // strcmp(char*, char*): 比较字符串，相同返回0, 不同则返回不同字符的差值，不可以用 == 比较，因为参数是字符指针
    // strncmp(char*, char*, int len): 比较指定长度，即只比较开头
    // strcpy(char*, char*): 拷贝字符串,因为参数是指针，所以可以传入字符数组的任意一个位置进行拷贝，可以实现连接的功能
    // strncpy(char*, char*, int len): 拷贝指定长度, 返回值是第一个参数地址
    // strchr(char*, char c): 查找字符首次出现的位置，找到返回地址，否则空指针
    // strrchr(char*, char c): 查找字符最后出现的位置，找到返回地址，否则空指针
    // strpbrk(char*, char*): 查找指定字符串中的任意字符，找到返回地址，否则空指针
    // strstr(char*, char*): 查找指定字符串首次出现的位置，找到地址，否则空指针
    // fprintf(char*, args): 将输出存储到指定字符数组

    // 移动字符串时候可能存在大量的拷贝
    // 当有需求时候，可以考虑使用移动指针的方式
    // 比如排序字符串，用字符串比较，交换指针地址后，实现字符串交换，更简单，更高效

    // int main(void); // 无参数主函数
    // int main(int argc, char* argv[]);    // 带参数主函数
    // 如有test.exe, test -r a b 时， argc = 2, argv[0] = "a", argv[1] = "b"
    // argc 是参数个数，argv是参数字符串数组

    // string => integer
    // atoi(): 字符串转整数，没有错误检查功能，只能转换开头，无法识别的返回0
    // atof(), atol：转换为 double 、 long

    // strtox(char*, char**, int base)
    // tips : 以 base 进制转换字符串为数组, 第一个是字符串指针，第二个是一个字符指针的指针地址，存放数字结尾的指针
    // strtol: 字符串转 long
    // strtoul: unsigned long
    // strtod: double
    // strtoll
    // strtoull

    // 标识符：符合命名规则，可以用来指定对象内容（赋值）
    // 左值：指定了一个对象内容可以称为左值
    // 例子
    // int i = 1; int* p = &i;
    // i 和 p 是一个标识符， i 和 *p 是一个左值

    // 可修改的左值：可以修改指定内容的左值
    // 例子
    // const char* p = "hello"; 这是一个可修改的左值
    // 此处，由于char* p 是一个字符指针，所以有一个标识符 p， 左值 p、*p、"hello"
    // const 在前面，意味着无法修改指向的值，所以 *p 是一个不可修改的左值
    //              但是可以修改存储的内容，所以 p 是一个可修改的左值
    // 同时，字符串字面量 "hello" 本身指向了存储的对象，但是无法被修改（起码通过 "hello" 无法被修改）
    // 所以 "hello" 是一个不可修改的左值

    // 作用域: 描述程序中可访问标识符的区域（块作用域、函数作用域、函数原型作用域、文件作用域）
    // 块作用域：花括号括起来的一个块，当然还有一下情况
    //      for(int i = 1;;)
    //          int j = i;
    //      此处的 i 和 j 也在块作用域
    // 函数作用域：仅用于 goto 语句标签，即使是内部块中的标签也会延申到整个函数
    // 函数原型作用域：函数原型中的参数只在函数原型有用，所以等于没用，通常可以不写形参名，除了下面的变长数组
    //      get(int n, int m, a[n][m]) // 注：变长数组是表示定义的长度是变量，并非表示长度可变
    // 文件作用域：定义在函数外面的变量具有文件作用域，又分内部链接和外部链接

    // 链接(无链接、内部链接、外部链接)
    // 翻译单元：一个源代码文件及其包含的文件，称为一个翻译单元
    // 块作用域、函数作用域、函数原型作用域都是无链接的
    // 在函数外如下定义 int i; static int j;    // 他们具有文件作用域
    // 但是 i 是外部链接的文件作用域，j 是内部链接的文件作用域
    // 外部链接的文件作用域：可以多文件程序中使用，（简称：程序作用域
    // 内部链接的文件作用域：只能在翻译单元内使用，（简称：文件作用域，全局作用域

    // 存储期(静态存储期，线程存储期，自动存储期，动态内存存储期)
    // 作用域和链接描述了标识符的可见性，存储器描述了对应访问对象的生存期
    // 静态存储期：在程序执行期间会一直存在，文件作用域中和用 static 声明的变量都属于 静态存储期
    // 线程存储期：从声明到线程结束一直存在，关键字 _Thead_local，每个线程会获得一个私有备份
    // 自动存储期：从进入块或函数到退出之前一直存在，变成数组则从声明处开始
    // 其他说明
    // int fun() { static int i = 10; return &i; }
    // 虽然以上声明属于静态存储期，但是因为变量i是块作用域，在函数外无法正常调用 i，如果有需求可以通过返回指针的方式继续使用

    // 存储类别(自动、寄存器、静态外部链接、静态内部链接、静态无链接)
    // 自动变量：自动存储期、块作用域、无连接的是自动变量，可以显示调用 auto 声明  auto int i;当然，没有初始化的时候，他可能会是任意值
    // 寄存器变量：自动存储期，块作用域，无连接，使用 regiser int i;声明，速度会更快，但是无法获取地址，
    //      但是编译器会根据寄存器的情况分配，他也有可能变成自动变量，但是也不能使用地址运算符

    for(int i = 0; i < 10; ++i)
        printf("%d\n", i);
}
```